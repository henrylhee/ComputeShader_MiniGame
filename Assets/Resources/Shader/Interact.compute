// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

// ############## constant ###########
int threadCountX;
int threadCountY;
int resoX;
int resoY;
int indexCount;

struct FactionSettings
{
    float conquerRate;
    float conquerStrength;
    float expansionRate;
    float expansionStrength;
    float4 color;
};
StructuredBuffer<FactionSettings> factionDataBuffer;



// ######### read/write data ############
int hasInteracted;
float timeSeed;


struct Point
{
    int index;
    int faction;
    int isActive;
    int dummy;
    int4 neighbourIndices;
};
RWStructuredBuffer<Point> pointsBuffer;

RWBuffer<float> impactValuesBuffer;

RWTexture2D<float4> colorTexture;


RWBuffer<float4> test;


float rand3dTo1d(float3 value, float3 dotDir = float3(12.9898, 78.233, 37.719))
{
	//make value smaller to avoid artefacts
    float3 smallValue = sin(value);
	//get scalar value from 3d vector
    float random = dot(smallValue, dotDir);
	//make value more random by making it bigger and then taking the factional part
    random = frac(sin(random) * 143758.5453);
    return random;
}


[numthreads(8,8,1)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (hasInteracted == 0)
    {   
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
                ////-------------
        if (id.x == 99 && id.y == 99)
        {
            //test[0] = float4(pointsBuffer[index].faction, impactValuesBuffer[4 * pointsBuffer[index].neighbourIndices[1] + 1], impactValuesBuffer[4 * pointsBuffer[index].neighbourIndices[2] + 2], impactValuesBuffer[4 * pointsBuffer[index].neighbourIndices[3] + 3]);
            test[0] = float4(timeSeed, 0, hasInteracted, 0);
        }
        
        
        int index = id.y * resoX + id.x;
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int faction = pointsBuffer[index].faction;
        
        if (faction == 0 || pointsBuffer[index].isActive == 0)
        {
            return;
        }
        
        float value = rand3dTo1d(float3(st, timeSeed));
    
        for (int direction = 0; direction < 4; direction++)
        {
            int neighbourIndex = pointsBuffer[index].neighbourIndices[direction];
            if (neighbourIndex != indexCount)
            {
                if (pointsBuffer[neighbourIndex].faction == 0)
                {
                    if (value < factionDataBuffer[faction].expansionRate)
                    {
                        impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].expansionStrength;
                    }
                }
                else
                {
                    if (value < factionDataBuffer[faction].conquerRate)
                    {
                        impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].conquerStrength;
                    }
                }
                pointsBuffer[neighbourIndex].isActive = 1;
            }
        }
    }
    else
    {
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
    
        if (pointsBuffer[index].isActive == 0)
        {
            return;
        }
    
        //###########
        //if (id.x == 100 && id.y == 99)
        //{
        //    test[0] = int4(pointsBuffer[pointsBuffer[index].neighbourIndices.x].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.y].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.z].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.w].isActive); //test[0] + int4(1,0,0,0);
        //    //test[0] = pointsBuffer[index].neighbourIndices;

        //}
        
        int faction = pointsBuffer[index].faction;
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;
        bool isActive = false;
    
        for (int i = 0; i < 4; i++)
        {
            int neighbourIndex = neighbourIndices[i];
            if (neighbourIndex == indexCount)
            {
                continue;
            }
            if (pointsBuffer[neighbourIndex].faction != faction)
            {
                isActive = true;
                break;
            }
        }
        if (isActive == false)
        {
            pointsBuffer[index].isActive = 0;
            return;
        }
        
        float maxImpact = impactValuesBuffer[4 * index];
        int successfulneighbourDir = 0;
        for (int j = 1; j < 4; j++)
        {
            if (maxImpact < impactValuesBuffer[4 * index + j])
            {
                maxImpact = impactValuesBuffer[4 * index + j];
                successfulneighbourDir = j;
            }
        }
        ////-------------
        //if (id.x == 100 && id.y == 99)
        //{
        //    test[0] = float4(impactValuesBuffer[4 * index], impactValuesBuffer[4 * index + 1], impactValuesBuffer[4 * index + 2], impactValuesBuffer[4 * index + 3]);

        //}
        if (maxImpact == 0)
        {
            return;
        }
        
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        float defence = rand3dTo1d(float3(st, timeSeed * 2.1));
        if (defence > maxImpact)
        {
            return;
        }
        
        
        else
        {
            for(int i = 0; i < 4; i++)
            {
                impactValuesBuffer[4 * index + i] = 0;
            }
        }
        int newFaction = pointsBuffer[neighbourIndices[(successfulneighbourDir + 2) % 4]].faction;
    
        pointsBuffer[index].faction = newFaction;
        int y = floor(index / resoX);
        int x = index - resoX * y;
        colorTexture[float2(x, y)] = factionDataBuffer[newFaction].color;     
    }   
}




