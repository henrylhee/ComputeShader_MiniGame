// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInjectPoints

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct FactionSettings
{
    float conquerRate;
    float conquerStrength;
    float expansionRate;
    float expansionStrength;
    float4 color;
};

struct Point
{
    int index;
    int faction;
    int isActive;
    float brightnessInput;
    int4 neighbourIndices;
};


int threadCountX;
int threadCountY;
int resoX;
int resoY;
int indexCount;
int injectionReso;
int injectionCount;

float brightnessMin;
float brightnessInputIncrease;

float enemyStrength;

int hasInteracted;
float timeSeed;

StructuredBuffer<FactionSettings> factionDataBuffer;

RWStructuredBuffer<Point> pointsBuffer;
RWBuffer<float> impactValuesBuffer;
RWBuffer<int4> pointsInjectBuffer;
RWTexture2D<float4> colorTexture;


RWBuffer<float4> test;


void AdjustColorBrightness(int pointIndex, int2 colorIndex, int faction)
{
    float input = pointsBuffer[pointIndex].brightnessInput;
    if (input < 1.0)
    {
        input += brightnessInputIncrease;
        pointsBuffer[pointIndex].brightnessInput = input;

    }
    float fInput = 1.0 - sqrt(input) / (8.0/7.0);
    float4 c = factionDataBuffer[faction].color;
    colorTexture[colorIndex] = c * fInput;
}


float rand3dTo1d(float3 value, float3 dotDir = float3(12.9898, 78.233, 37.719))
{
	//make value smaller to avoid artefacts
    float3 smallValue = sin(value);
	//get scalar value from 3d vector
    float random = dot(smallValue, dotDir);
	//make value more random by making it bigger and then taking the factional part
    random = frac(sin(random) * 143758.5453);
    return random;
}


[numthreads(8,8,1)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (hasInteracted == 0)
    {   
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        int y = floor(index / resoX);
        int2 colorIndex = int2(index - resoX * y, y);
        int faction = pointsBuffer[index].faction;
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;
        int friendlyNeighbours = 0;
        int enemyNeighbours = 0;
        float attackValue = rand3dTo1d(float3(st, timeSeed));

        
        for (int direction = 0; direction < 4; direction++)
        {
            int neighbourIndex = neighbourIndices[direction];
            if (neighbourIndex == indexCount)
            {
                continue;
            }
            if (pointsBuffer[neighbourIndex].faction == 0)
            {
                if (attackValue < factionDataBuffer[faction].expansionRate)
                {
                    impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].expansionStrength;
                }
            }
            else if (pointsBuffer[neighbourIndex].faction == faction)
            {
                friendlyNeighbours++;
            }
            else
            {
                if (attackValue < factionDataBuffer[faction].conquerRate)
                {
                    impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].conquerStrength;
                }
                enemyNeighbours++;
            }
        }
        
        
        
        if (timeSeed > 1)
        {
            if (friendlyNeighbours < 3)
            {
                if (rand3dTo1d(float3(st, timeSeed * 3.14)) > 0.92 + friendlyNeighbours * 0.03 - enemyNeighbours * 0.04)
                {
                    pointsBuffer[index].faction = 0;
                    colorTexture[colorIndex] = float4(0, 0, 0, 1);
                    pointsBuffer[index].brightnessInput = 0;
                    return;
                }
            }
        }
    }
    else
    {
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        int y = floor(index / resoX);
        int2 colorIndex = int2(index - resoX * y, y);
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;


        int faction = pointsBuffer[index].faction;
    
        if (pointsBuffer[index].faction != 0)
        {
            AdjustColorBrightness(index, colorIndex, faction);
        }
        
        
        int successfulNeighbour;
        int4 activeNeighbours;
        float impactValuesCombined = 0;
        int inactiveNeighboursCount = 0;
        float randVal = rand3dTo1d(float3(st, timeSeed * 2.1));
        for (int j = 0; j < 4; j++)
        {
            if (impactValuesBuffer[4 * index + j] > 0)
            {
                activeNeighbours[j] = 1;         
                impactValuesCombined += impactValuesBuffer[4 * index + j];
            }
            else
            {
                activeNeighbours[j] = 0;
                inactiveNeighboursCount++;
            }
        }
        
        if (inactiveNeighboursCount == 4)
        {
            return;
        }
        else
        {
            float addedImpact = 0;
            float relRandomVal = randVal * impactValuesCombined;
            for (int i = 0; i < 4 ; i++)
            {
                if (activeNeighbours[i] == 1)
                {
                    addedImpact += impactValuesBuffer[4 * index + i];
                    if (relRandomVal < addedImpact)
                    {
                        successfulNeighbour = i;
                        break;
                    }

                }
            }
        }
        int newFaction = pointsBuffer[neighbourIndices[(successfulNeighbour + 2) % 4]].faction;

        //float defence;
        //if (faction == 1)
        //{
        //    if (randVal - enemyStrength > 0)
        //    {
        //        defence = randVal - enemyStrength;
        //    }
        //    else
        //    {
        //        defence = 0.0;
        //    }
        //}
        //if (defence > maxImpact)
        //{
        //    return;
        //}
        
        
        
        //if (id.x == 100 && id.y == 100)
        //{
        //    test[0] = float4(maxImpact, 666, enemyStrength, timeSeed);
        //}   
        
        
    
        pointsBuffer[index].faction = newFaction;
        
        colorTexture[colorIndex] = factionDataBuffer[newFaction].color;
        pointsBuffer[index].brightnessInput = 0;
    }   
}

[numthreads(8, 8, 1)]
void CSInjectPoints(int3 id : SV_DispatchThreadID)
{          
    if (id.x >= injectionReso)
    {
        return;
    }
    
    int index = id.y * injectionReso + id.x;
    if (index >= injectionCount)
    {
        return;
    }
    
    int4 injectPoints = pointsInjectBuffer[index];
    if (injectPoints.x < resoX && injectPoints.y < resoY && injectPoints.x >= 0 && injectPoints.y >= 0)
    {
        int pointsIndex = injectPoints.y * resoX + injectPoints.x;
        pointsBuffer[pointsIndex].faction = 1;
        colorTexture[int2(injectPoints.x, injectPoints.y)] = factionDataBuffer[1].color;
        pointsBuffer[index].brightnessInput = 0;
    }
    if (injectPoints.z < resoX && injectPoints.w < resoY && injectPoints.z >= 0 && injectPoints.w >= 0)
    {
        int pointsIndex = injectPoints.w * resoX + injectPoints.z;
        pointsBuffer[pointsIndex].faction = 1;
        colorTexture[int2(injectPoints.z, injectPoints.w)] = factionDataBuffer[1].color;
        pointsBuffer[index].brightnessInput = 0;
    }  
}



