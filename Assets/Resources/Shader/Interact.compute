// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInjectPoints

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct FactionSettings
{
    float conquerRate;
    float conquerStrength;
    float expansionRate;
    float expansionStrength;
    float4 color;
};

struct Point
{
    int index;
    int faction;
    int isActive;
    float brightnessInput;
    int4 neighbourIndices;
};


int threadCountX;
int threadCountY;
int resoX;
int resoY;
int indexCount;
int injectionReso;
int injectionCount;

float brightnessMin;
float brightnessInputIncrease;

int hasInteracted;
float timeSeed;

StructuredBuffer<FactionSettings> factionDataBuffer;

RWStructuredBuffer<Point> pointsBuffer;
RWBuffer<float> impactValuesBuffer;
RWBuffer<int4> pointsInjectBuffer;
RWTexture2D<float4> colorTexture;


RWBuffer<float4> test;


void AdjustColorBrightness(int pointIndex, int2 colorIndex, int faction)
{
    float input = pointsBuffer[pointIndex].brightnessInput;
    if (input < 1.0)
    {
        input += brightnessInputIncrease;
        pointsBuffer[pointIndex].brightnessInput = input;

    }
    float fInput = 1.0 - sqrt(input) / (8.0/7.0);
    float4 c = factionDataBuffer[faction].color;
    colorTexture[colorIndex] = c * fInput;
}


float rand3dTo1d(float3 value, float3 dotDir = float3(12.9898, 78.233, 37.719))
{
	//make value smaller to avoid artefacts
    float3 smallValue = sin(value);
	//get scalar value from 3d vector
    float random = dot(smallValue, dotDir);
	//make value more random by making it bigger and then taking the factional part
    random = frac(sin(random) * 143758.5453);
    return random;
}


[numthreads(8,8,1)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (hasInteracted == 0)
    {   
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int faction = pointsBuffer[index].faction;
        
        if (faction == 0 || pointsBuffer[index].isActive == 0)
        {
            return;
        }
        
        float value = rand3dTo1d(float3(st, timeSeed));
    
        for (int direction = 0; direction < 4; direction++)
        {
            int neighbourIndex = pointsBuffer[index].neighbourIndices[direction];
            if (neighbourIndex != indexCount)
            {
                if (pointsBuffer[neighbourIndex].faction == 0)
                {
                    if (value < factionDataBuffer[faction].expansionRate)
                    {
                        impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].expansionStrength;
                    }
                }
                else
                {
                    if (value < factionDataBuffer[faction].conquerRate)
                    {
                        impactValuesBuffer[4 * neighbourIndex + direction] = factionDataBuffer[faction].conquerStrength;
                    }
                }
                pointsBuffer[neighbourIndex].isActive = 1;
            }
        }
    }
    else
    {
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        int y = floor(index / resoX);
        int2 colorIndex = int2(index - resoX * y, y);
        int faction = pointsBuffer[index].faction;
    
        if (pointsBuffer[index].faction != 0)
        {
            AdjustColorBrightness(index, colorIndex, faction);
            
            //##### check stuff ######
            if (id.x == 5 && id.y == 5)
            {
                test[0] = float4(colorTexture[colorIndex].x, colorTexture[colorIndex].y, colorTexture[colorIndex].z, colorTexture[colorIndex].w);
                //test[0] = float4(timeSeed, 0, hasInteracted, 0);
            }
        }
        
        if (pointsBuffer[index].isActive == 0)
        {
            return;
        }
    
        //###########
        //if (id.x == 100 && id.y == 99)
        //{
        //    test[0] = int4(pointsBuffer[pointsBuffer[index].neighbourIndices.x].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.y].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.z].isActive, pointsBuffer[pointsBuffer[index].neighbourIndices.w].isActive); //test[0] + int4(1,0,0,0);
        //    //test[0] = pointsBuffer[index].neighbourIndices;

        //}
        
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;
        bool isActive = false;
        int friendlyNeighbours = 0;
        int enemyNeighbours = 0;
        
        for (int i = 0; i < 4; i++)
        {
            int neighbourIndex = neighbourIndices[i];
            if (neighbourIndex == indexCount)
            {
                continue;
            }
            if (pointsBuffer[neighbourIndex].faction != faction)
            {
                isActive = true;
                
                if (pointsBuffer[neighbourIndex].faction != 0)
                {
                    enemyNeighbours++;
                }
                
                break;
            }
            else
            {
                friendlyNeighbours++;
            }
        }
        if (isActive == false)
        {
            pointsBuffer[index].isActive = 0;
            return;
        }
        
        if (friendlyNeighbours < 3)
        {
            if (rand3dTo1d(float3(st, timeSeed * 3.14)) > 0.92 + friendlyNeighbours * 0.03 - enemyNeighbours * 0.04)
            {
                pointsBuffer[index].faction = 0;
                colorTexture[colorIndex] = float4(0, 0, 0, 1);
                pointsBuffer[index].brightnessInput = 0;
                return;
            }
        }
        
        float maxImpact = impactValuesBuffer[4 * index];
        int successfulneighbourDir = 0;
        for (int j = 1; j < 4; j++)
        {
            if (maxImpact < impactValuesBuffer[4 * index + j])
            {
                maxImpact = impactValuesBuffer[4 * index + j];
                successfulneighbourDir = j;
            }
        }
        ////-------------
        //if (id.x == 100 && id.y == 99)
        //{
        //    test[0] = float4(impactValuesBuffer[4 * index], impactValuesBuffer[4 * index + 1], impactValuesBuffer[4 * index + 2], impactValuesBuffer[4 * index + 3]);

        //}
        if (maxImpact == 0)
        {
            return;
        }
        
        float defence = rand3dTo1d(float3(st, timeSeed * 2.1));
        if (defence > maxImpact)
        {
            return;
        }
        
        
        else
        {
            for(int i = 0; i < 4; i++)
            {
                impactValuesBuffer[4 * index + i] = 0;
            }
        }
        int newFaction = pointsBuffer[neighbourIndices[(successfulneighbourDir + 2) % 4]].faction;
    
        pointsBuffer[index].faction = newFaction;
        
        colorTexture[colorIndex] = factionDataBuffer[newFaction].color;
        pointsBuffer[index].brightnessInput = 0;
    }   
}

[numthreads(8, 8, 1)]
void CSInjectPoints(int3 id : SV_DispatchThreadID)
{          
    if (id.x >= injectionReso)
    {
        return;
    }
    
    int index = id.y * injectionReso + id.x;
    if (index >= injectionCount)
    {
        return;
    }
    
    int4 injectPoints = pointsInjectBuffer[index];
    if (injectPoints.x < resoX && injectPoints.y < resoY && injectPoints.x >= 0 && injectPoints.y >= 0)
    {
        int pointsIndex = injectPoints.y * resoX + injectPoints.x;
        pointsBuffer[pointsIndex].faction = 1;
        pointsBuffer[pointsIndex].isActive = 1;
        colorTexture[int2(injectPoints.x, injectPoints.y)] = factionDataBuffer[1].color;
    }
    if (injectPoints.z < resoX && injectPoints.w < resoY && injectPoints.z >= 0 && injectPoints.w >= 0)
    {
        int pointsIndex = injectPoints.w * resoX + injectPoints.z;
        pointsBuffer[pointsIndex].faction = 1;
        pointsBuffer[pointsIndex].isActive = 1;
        colorTexture[int2(injectPoints.z, injectPoints.w)] = factionDataBuffer[1].color;
    }  
}



