// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInjectPoints

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct FactionSettingsConstant
{
    float conquerRate;
    float dummy;
    float expansionRate;
    float expansionStrength;
    float4 color;
};

struct FactionSettingsDynamic
{
    float conquerStrength;
    float dummy1;
    float dummy2;
    float dummy3;
};
struct Point
{
    int index;
    int faction;
    int isActive;
    float brightnessInput;
    int4 neighbourIndices;
};


int threadCountX;
int threadCountY;
int resoX;
int resoY;
int indexCount;
int injectionReso;
int injectionCount;

float brightnessMin;
float brightnessInputIncrease;

float enemyStrength;

int hasInteracted;
float timeSeed;

StructuredBuffer<FactionSettingsConstant> factionDataConstantBuffer;
StructuredBuffer<FactionSettingsDynamic> factionDataDynamicBuffer;

RWStructuredBuffer<Point> pointsBuffer;
RWBuffer<float> impactValuesBuffer;
RWBuffer<int4> pointsInjectBuffer;
RWTexture2D<float4> colorTexture;

RWBuffer<float4> test;


void AdjustColorBrightness(int pointIndex, int2 colorIndex, int faction)
{
    float input = pointsBuffer[pointIndex].brightnessInput;
    if (input < 1.0)
    {
        input += brightnessInputIncrease;
        pointsBuffer[pointIndex].brightnessInput = input;

    }
    float fInput = 1.0 - sqrt(input) / (8.0/7.0);
    float4 c = factionDataConstantBuffer[faction].color;
    colorTexture[colorIndex] = c * fInput;
}


float rand3dTo1d(float3 value, float3 dotDir = float3(12.9898, 78.233, 37.719))
{
	//make value smaller to avoid artefacts
    float3 smallValue = sin(value);
	//get scalar value from 3d vector
    float random = dot(smallValue, dotDir);
	//make value more random by making it bigger and then taking the factional part
    random = frac(sin(random) * 143758.5453);
    return random;
}


[numthreads(8,8,1)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (hasInteracted == 0)
    {   
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        int faction = pointsBuffer[index].faction;
        
        if (faction == 0)
        {
            return;
        }
        
        
        int y = floor(index / resoX);
        int2 colorIndex = int2(index - resoX * y, y);
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;
        int friendlyNeighbours = 0;
        int enemyNeighbours = 0;
        float attackValue = rand3dTo1d(float3(st, timeSeed + 0.3));

        
        for (int direction = 0; direction < 4; direction++)
        {
            int neighbourIndex = neighbourIndices[direction];
            if (neighbourIndex == indexCount)
            {
                continue;
            }
            if (pointsBuffer[neighbourIndex].faction == 0)
            {
                if (attackValue < factionDataConstantBuffer[faction].expansionRate)
                {
                    impactValuesBuffer[neighbourIndex * 4 + direction] = factionDataConstantBuffer[faction].expansionStrength;
                }
            }
            else if (pointsBuffer[neighbourIndex].faction == faction)
            {
                // conquer on tiles works as an ancer else on the border the opposing faction always has advanatge in tile conquest
                //if (attackValue < factionDataConstantBuffer[faction].conquerRate)
                //{
                //    impactValuesBuffer[neighbourIndex * 4 + direction] = factionDataDynamicBuffer[faction].conquerStrength;
                //}
                friendlyNeighbours++;
            }
            else
            {                
                if (attackValue < factionDataConstantBuffer[faction].conquerRate)
                {
                    impactValuesBuffer[neighbourIndex * 4 + direction] = factionDataDynamicBuffer[faction].conquerStrength;
                }
                enemyNeighbours++;
            }
        }
    }
    else
    {
        if (id.x >= resoX || id.y >= resoY)
        {
            return;
        }
        
        int index = id.y * resoX + id.x;
        int y = floor(index / resoX);
        int2 colorIndex = int2(index - resoX * y, y);
        float2 st = float2((float) id.x / threadCountX, (float) id.y / threadCountX);
        int4 neighbourIndices = pointsBuffer[index].neighbourIndices;

        
        int faction = pointsBuffer[index].faction;
        
             
        float impactValuesCombined = 0;
        int enemyNeighbours = 0;
        float randVal = rand3dTo1d(float3(st, timeSeed + 2.1));
        float offset = 0;
        float relRandomVal = randVal * impactValuesCombined;
        int newFaction = 0;
        
        for (int dir = 0; dir < 4; dir++)
        {
            int impactIndex = index * 4 + dir;
            int neighbourIndex = neighbourIndices[dir];
            if (impactValuesBuffer[impactIndex] > 0.0)
            {
                impactValuesCombined += impactValuesBuffer[impactIndex];
            }
            if (pointsBuffer[neighbourIndex].faction != faction && pointsBuffer[neighbourIndex].faction != 0)
            {
                enemyNeighbours++;
            }
        }
        
        //if (timeSeed > 1)
        //{
        //    if (enemyNeighbours < 3)
        //    {
        //        if (rand3dTo1d(float3(st, timeSeed + 3.14)) > 0.5 + enemyNeighbours * 0.1)
        //        {   
        //            for (int i = 0; i < 4; i++)
        //            {
        //                impactValuesBuffer[index * 4 + i] = 0.0;
        //            }
                    
        //            return;
        //        }
        //    }
        //}
               
        for (int direction = 0; direction < 4; direction++)
        {
            if (impactValuesBuffer[index * 4 + direction] > 0.0)
            {
                //impactValuesBuffer[index * 4 + direction] = 0.0; ---> not setting value to 0 after conquering leads to an influence from the conquering faction with better visual results

                if (relRandomVal <= offset + impactValuesBuffer[index * 4 + direction])
                {
                    newFaction = pointsBuffer[neighbourIndices[(direction + 2) % 4]].faction;

                    if (newFaction != faction)
                    {
                        pointsBuffer[index].faction = newFaction;
        
                        colorTexture[colorIndex] = factionDataConstantBuffer[newFaction].color;
                        pointsBuffer[index].brightnessInput = 0;
                        break;
                    }
                }
                offset += impactValuesBuffer[index * 4 + direction];
            }
        }
        //for (int i = 0; i < 4; i++)
        //{
        //    impactValuesBuffer[index * 4 + i] = 0.0;
        //}
        
        if (faction != 0 && faction != newFaction)
        {
            AdjustColorBrightness(index, colorIndex, faction);
        }
        

        
        //float defence;
        //if (faction == 1)
        //{
        //    if (randVal - enemyStrength > 0)
        //    {
        //        defence = randVal - enemyStrength;
        //    }
        //    else
        //    {
        //        defence = 0.0;
        //    }
        //}
        //if (defence > maxImpact)
        //{
        //    return;
        //}
    }   
}

[numthreads(8, 8, 1)]
void CSInjectPoints(int3 id : SV_DispatchThreadID)
{          
    if (id.x >= injectionReso)
    {
        return;
    }
    
    int index = id.y * injectionReso + id.x;
    if (index >= injectionCount)
    {
        return;
    }
    
    int4 injectPoints = pointsInjectBuffer[index];
    if (injectPoints.x < resoX && injectPoints.y < resoY && injectPoints.x >= 0 && injectPoints.y >= 0)
    {
        int pointsIndex = injectPoints.y * resoX + injectPoints.x;
        
        colorTexture[int2(injectPoints.x, injectPoints.y)] = factionDataConstantBuffer[1].color;
        if (pointsBuffer[pointsIndex].faction != 1)
        {
            pointsBuffer[pointsIndex].faction = 1;
            colorTexture[int2(injectPoints.x, injectPoints.y)] = factionDataConstantBuffer[1].color;
            pointsBuffer[pointsIndex].brightnessInput = 0;
        }
    }
    if (injectPoints.z < resoX && injectPoints.w < resoY && injectPoints.z >= 0 && injectPoints.w >= 0)
    {
        int pointsIndex = injectPoints.w * resoX + injectPoints.z;

        if (pointsBuffer[pointsIndex].faction != 1)
        {
            pointsBuffer[pointsIndex].faction = 1;
            colorTexture[int2(injectPoints.z, injectPoints.w)] = factionDataConstantBuffer[1].color;
            pointsBuffer[pointsIndex].brightnessInput = 0;
        }
    }  
}



